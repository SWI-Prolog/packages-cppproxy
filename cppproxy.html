<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>
<HEAD>
<TITLE>SWI-Prolog C++ Proxy</TITLE>
</HEAD>
<BODY BGCOLOR="white"> 
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<CENTER>

<H1>SWI-Prolog C++ Proxy</H1>

</CENTER>
<HR>
<CENTER>
<I>Jan Wielemaker <BR>
HCS, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A HREF="mailto:wielemak@science.uva.nl">wielemak@science.uva.nl</A></I>
</CENTER>
<HR>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<CENTER><H3>Abstract</H3></Center>
<TABLE WIDTH="90%" ALIGN=center BORDER=2 BGCOLOR="#f0f0f0"><TR><TD>
This document describes an infrastructure for calling Prolog from C++ 
that allows for controlled access from C++ based on a generated
<EM>proxy</EM> class. In our first target the proxy class talks to a 
multi-threaded Prolog server using TCP/IP sockets. In future versions 
this will be extended with SSL sockets, pipes and native DLL embedding. 
The C++ and Prolog sourcecode for all these scenarios is identical, 
except for the code that initialises the system.
</TABLE>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<UL>
<LI><A HREF="#sec:1"><B>1 Introduction</B></A>
<LI><A HREF="#sec:2"><B>2 Overview</B></A>
<LI><A HREF="#sec:3"><B>3 Related techniques</B></A>
<UL>
<LI><A HREF="#sec:3.1">3.1 Prolog Portability</A>
</UL>
<LI><A HREF="#sec:4"><B>4 Defining the interface</B></A>
<LI><A HREF="#sec:5"><B>5 Compound data as seen from C++</B></A>
<LI><A HREF="#sec:6"><B>6 Generating the C++ proxy</B></A>
<LI><A HREF="#sec:7"><B>7 Using the proxy classes</B></A>
<UL>
<LI><A HREF="#sec:7.1">7.1 Passing primitive datatypes</A>
<LI><A HREF="#sec:7.2">7.2 Passing compound data</A>
<LI><A HREF="#sec:7.3">7.3 Non-deterministic queries</A>
<LI><A HREF="#sec:7.4">7.4 Nesting queries</A>
</UL>
<LI><A HREF="#sec:8"><B>8 Running the server</B></A>
<LI><A HREF="#sec:9"><B>9 Putting it all together: a complete example</B></A>
<LI><A HREF="#sec:10"><B>10 Status</B></A>
<UL>
<LI><A HREF="#sec:10.1">10.1 Portability</A>
</UL>
<LI><A HREF="#sec:11"><B>11 Installation</B></A>
<UL>
<LI><A HREF="#sec:11.1">11.1 Unix systems</A>
<LI><A HREF="#sec:11.2">11.2 Windows system</A>
</UL>
</UL>

<P>

<H2><A NAME="sec:1">1 Introduction</A></H2>

<P>SWI-Prolog is well suitable for writing a wide range of complete 
applications without introducing other languages into the system and an 
even wider range when linking C/C++ coded shared objects to access 
external resources, in real-life Prolog is often embedded in systems 
written in other languages. The reasons vary. Re-use of existing code, 
expertise in the development team or external requirements are commonly 
encountered motivations.

<P>Embedding Prolog is not a logical choice in our view. An important 
part of the power of Prolog can be found in its development system where 
retrying goals and reloading patched code on the running system speedup 
development considerably. In embedded system these features are often 
lost or severely limited due to lack of access to the interactive Prolog 
toplevel or inability of the rest of the application to stay 
synchronised with the dynamic nature of the Prolog part of the 
application.

<P>If you have to embed there are several options for doing so, each 
with specific advantages and disadvantages.

<P>
<UL>
<LI><I>Linking as library</I><BR>
Linking Prolog as a library is attractive as it allows for two-way 
communication at very low overhead. It is also the most complicated 
approach, often loosing access to the Prolog toplevel entirely, 
introducing possibly threading and (on POSIX systems) signal 
synchronisation problems, link conflicts and difficulty to localise 
bugs.

<P>
<LI><I>Using pipes</I><BR>
By using anonymous pipes between the hosting system and Prolog we 
introduce a seperation that makes it easier to localise problems and 
reliably stop and start Prolog. The price is -again- loosing the Prolog 
toplevel, slower communication and pipes only provide a single 
communication channal.

<P>
<LI><I>Using sockets</I><BR>
Using sockets connecting to a continuously running multi-threaded Prolog 
server does keep access to the Prolog toplevel, offers very short 
startup times and allows to distribute the applications over multiple 
hosts on the network. The price is that it is way harder to setup the 
communication (something must ensure the server is running and allocate 
a port for it) and the server must be written thread-safe.
</UL>

<H2><A NAME="sec:2">2 Overview</A></H2>

<P>This packages consists of the following components:

<P>
<UL>
<LI><I> Interface definition</I><BR>
The library <CODE>cpp_interface.pl</CODE> and <CODE>typedef.pl</CODE> 
define directives that allow you to specify the predicates that are 
callable from C++ and their types. Only specified predicates can be 
called and only with matching types. Restricting what can be called 
greatly improves security when used in a server setting. <A HREF="#sec:itfdecl">Section 
4</A> describes these declarations.

<P>
<LI><I> Code generation</I><BR>
The library <CODE>cpp_codegen.pl</CODE> defines the code generator. The 
code generator is used to create the C++ source for a proxy class that 
is used in the C++ client to talk to Prolog. <A HREF="#sec:codegen">Section 
6</A> describes generating the C++ proxy.

<P>
<LI><I> Prolog server</I><BR>
When using sockets, the library <CODE>cpp_server.pl</CODE> defines the 
Prolog server. See <A HREF="#sec:server">section 8</A> for details.

<P>
<LI><I> C++ client library</I><BR>
The file <CODE>SWI-proxy.cpp</CODE> and <CODE>SWI-Proxy.h</CODE> provide 
the base classes for the client proxy.
</UL>

<H2><A NAME="sec:3">3 Related techniques</A></H2>

<P>The technique used in this package are not new nor unique. 
Inter-language communication has been a topic in ICT for a long period, 
resulting in various widespread and well established solutions. The 
power of this solution is that it is tailured to Prolog's features such 
as non-deterministic predicates, lightweight, simple and fast. The 
weakness is of course being bound to Prolog and, currently, C++. Proxy 
generators can be defined for other languages, reusing most of the 
infrastructure except for the details of the code generation.

<P>
<UL>
<LI><I>CORBA</I><BR>
CORBA generates language specific proxies from a language neutral (IDL) 
specification. There are no bindings for Prolog. We once wrote a proxy 
generator between the C++ proxy and Prolog. This design is fairly 
elegant and produces fast interprocess communication. CORBA however is a 
complicated big system that require considerable resources for doing 
even the smallest tasks.

<P>
<LI><I>HTTP (optionally with SOAP)</I><BR>
Using the Prolog HTTP server is another alternative. HTTP provides the 
basic message <EM>envelope</EM>. The message content is still undefined. 
SOAP (an XML based content format) can be used here. Backtracking over 
solutions is hard to implement based on the stateless HTTP protocol. The 
approach is much more complicated and the various protocol layers 
require much more data and processing time. Experience show latency 
times of approx. a few milliseconds, where our server shows latency 
times of approx. 0.1 millisecond (AMD 1600+, SuSE Linux).

<P>
<LI><I>InterProlog</I><BR>
InterProlog is a stream-based connection to Java. I have no experience 
with it.

<P>
<LI><I>SWI-Prolog C++ interface</I><BR>
Using the native SWI-Prolog C++ interface does not provide network 
transparency and is much harder to program. The advantage is that it 
allows for mutual calling, more threading alternatives and many more.
</UL>

<H3><A NAME="sec:3.1">3.1 Prolog Portability</A></H3>

<P>The design can work with other Prolog systems. The server exploits 
multi-threading, but with some limitations this can be changed to run in 
a single thread. The proxy generator is portable with some effort and it 
is also possible to generate the proxy with SWI-Prolog and use it with a 
server written in another Prolog system. The proxy itself is pure C++, 
knowing nothing about Prolog.

<H2><A NAME="sec:4">4 Defining the interface</A></H2>

<A NAME="sec:itfdecl"></A>

<P>The interface definition defines the C++ callable predicates as well 
as their types and modes. The interface only deals with ground terms. 
The type language syntax is defined in the library <CODE>typedef.pl</CODE> 
and is based on the Mycroft/O'Keefe type language.

<DL>

<P>
<DT><A NAME="type/1"><STRONG>type</STRONG>(<VAR>TypeSpec</VAR>)</A><DD>
If <VAR>TypeSpec</VAR> is of the form <VAR>Alias</VAR> = <VAR>Type</VAR>,
<VAR>Alias</VAR> is an alias for the type named <VAR>Type</VAR>. If <VAR>TypeSpec</VAR> 
is of the form <VAR>Type</VAR> <TT>-&gt;</TT> <VAR>Def</VAR>, <VAR>Def</VAR> 
is the definition of <VAR>Type</VAR>. Polymorphism is expressed using 
multiple definitions seperated by the <CODE>|</CODE> (vertical bar) 
symbol.<A NAME=back-to-note-1 HREF="index.html#note-1"> (1)</A> A single 
definition is a term whose arguments define the types of the arguments.

<P>There are three <EM>primitive</EM> types: <CODE>integer</CODE>, <CODE>float</CODE> 
and <CODE>atom</CODE>.
</DL>

<P>Valid type declarations for our C++ interface do not use polymorphism 
and a fully expanded type definition consists of structures and 
primitive types. The argument <EM>names</EM> for compound types are 
derived from the type-name and usually bound to a real type using a 
type-alias. Here is an example:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- type first_name = atom.
:- type last_name  = atom.
:- type age        = integer.

:- type person -&gt; person(first_name, last_name, age).
</PRE>
</TABLE>

<P>The callable predicates are specified using the library
<CODE>cpp_interface.pl</CODE>, which defines two directives.

<DL>

<P>
<DT><A NAME="cpp_callable/1"><STRONG>cpp_callable</STRONG>(<VAR>Head [= Attributes], ...</VAR>)</A><DD>
Defines <VAR>Head</VAR> to be callable from C++. <VAR>Head</VAR> has the 
same number of argument as the predicate that must be callable. Each 
argument is of the form +<VAR>Type</VAR> or -<VAR>Type</VAR> for resp. an
<EM>input</EM> and <EM>output</EM> argument. <VAR>Attributes</VAR> is a 
list of attributes. Currently defined attributes are:

<DL>

<P>
<DT><STRONG>one</STRONG><DD>
Predicate succeeds exactly ones. Failure is an error. If the predicate 
succeeds non-deterministically the choicepoints are discarded (cut). 
Such predicates are mapped to a <CODE>void</CODE> method on the C++ 
proxy class. If the predicate fails this is mapped to a C++ exception. 
This is the default.

<P>
<DT><STRONG>zero_or_one</STRONG><DD>
Predicates fails or succeeds ones. If the predicate succeeds 
non-deterministically the choicepoints are discarded (cut). Such 
predicates are mapped to an <CODE>int</CODE> method on the C++ proxy 
class returning <CODE>FALSE</CODE> if the predicate fails and <CODE>TRUE</CODE> 
if it succeeds.

<P>
<DT><STRONG>zero_or_more</STRONG><DD>
Predicate is non-deterministic. Such predicates are mapped to a subclass 
of class <B>PlQuery</B>.

<P>
<DT><STRONG>as</STRONG>(<VAR>Name</VAR>)<DD>
If present, the predicate is mapped to a C++ method or query class named <VAR>Name</VAR> 
instead of the name of the predicate. This allows for mapping different 
calling patterns of the same predicate to different C++ methods or 
classes.
</DL>

<P>
<DT><A NAME="cpp_type/1"><STRONG>cpp_type</STRONG>(<VAR>CName = Functor</VAR>)</A><DD>
Specifies that the Prolog type <VAR>Functor</VAR> is represented by the 
C++ class CName. This allows for different naming conventions in the 
Prolog and C++ world.
</DL>

<P>The examples below depend on the type examples above.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- cpp_callable
        version(-atom) = [one],
        find_person_younger_than(+age, -person) = [zero_or_more].

version('0.0').

find_person_younger_than(MaxAge, person(FirstName, LastName, Age)) :-
        person(FirstName, LastName, Age),
        Age =&lt; MaxAge.
</PRE>
</TABLE>

<H2><A NAME="sec:5">5 Compound data as seen from C++</A></H2>

<A NAME="cppcompound"></A>

<P>Compound data that is to be communicated to Prolog is represented as 
a C++ class. This class must provide methods to fetch the components for 
use as a predicate input argument and with a method to create fill an 
instance of this class for predicate output arguments. These methods 
are:

<DL>

<P>
<DT><A NAME="initialize()"><VAR>void</VAR> <STRONG>initialize</STRONG>(<VAR>t1 
a1, t2 a2, ...</VAR>)</A><DD>
The initialize method is called with as many objects of the proper type 
as there are arguments in the Prolog term. The primitive types are
<CODE>long</CODE>, (for Prolog integers) <CODE>double</CODE> (for Prolog 
floats) and the C++ <EM>std</EM> class <CODE>string</CODE> for atoms.

<P>For each named field (see <A HREF="#sec:itfdecl">section 4</A>) a 
function must be provided that extracts the field and returns the 
appropriate type. For atom typed fields the return value can be an std <CODE>string</CODE> 
or a plain C <CODE>char*</CODE>.
</DL>

<P>Below is a possible implementation for the above defined person 
class.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

class person
{ 
public:
  char *first_name;
  char *last_name;
  int age;

  person()
  { first_name = NULL;
    last_name = NULL;
    age = -1;
  };
  ~person()
  { if ( first_name ) free(first_name);
    if ( last_name ) free(last_name);
  }

  char *get_first_name() const { return first_name; }
  char *get_last_name() const  { return last_name; }
  long  get_age() const  { return age; }

  void initialize(string fn, string ln, long years)
  { if ( first_name ) free(first_name);
    if ( last_name  ) free(last_name);

    first_name = strdup(fn.c_str());
    last_name  = strdup(ln.c_str());
    age = years;
  }
};
</PRE>
</TABLE>

<H2><A NAME="sec:6">6 Generating the C++ proxy</A></H2>

<A NAME="sec:codegen"></A>

<P>The C++ proxy class is automatically generated from the Prolog 
declarations using the library <CODE>cpp_codegen.pl</CODE>. To generate 
the code load this library in a Prolog process that has all the
<A NAME="idx:cppcallable1:1"></A><A HREF="#cpp_callable/1">cpp_callable/1</A> 
and type declarations in place and invoke the predicate
<A NAME="idx:cppservercode2:2"></A><A HREF="#cpp_server_code/2">cpp_server_code/2</A>:

<DL>

<P>
<DT><A NAME="cpp_server_code/2"><STRONG>cpp_server_code</STRONG>(<VAR>+File, 
+Options</VAR>)</A><DD>
Generate the C++ proxy class to access the deterministic predicates and 
the query classes for the non-deterministic predicates and write them to 
the given <VAR>File</VAR>. <VAR>Options</VAR> consists of

<DL>

<P>
<DT><STRONG>server_class</STRONG>(<VAR>Name</VAR>)<DD>
Name of the proxy class. If omitted it is called <CODE>MyProxy</CODE>.
</DL>

</DL>

<H2><A NAME="sec:7">7 Using the proxy classes</A></H2>

<H3><A NAME="sec:7.1">7.1 Passing primitive datatypes</A></H3>

<P>Primitive data are the Prolog types integer, float and atom.

<H3><A NAME="sec:7.2">7.2 Passing compound data</A></H3>

<P>Compound data is represented as a compound term in Prolog and, unless 
renamed using <A NAME="idx:cpptype2:3"></A><B>cpp_type/2</B>, an equally 
named class in C++.

<H3><A NAME="sec:7.3">7.3 Non-deterministic queries</A></H3>

<A NAME="sec:ndet"></A>

<P>The proxy for a non-deterministic predicates is a subclass of
<CODE>PlQuery</CODE>. The name of the class is the name of the 
predicate, unless modified using the <CODE>as(Name)</CODE> attribute 
with <A NAME="idx:cppcallable1:4"></A><A HREF="#cpp_callable/1">cpp_callable/1</A>. 
A query is started by creating an instance of this class using a pointer 
to the proxy as argument. The only method defined on this class is 
::next_solution(). This method uses the same arguments as the proxy 
methods that represent deterministic queries. The following example 
fetches all functors with arity 3 defined in Prolog:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- use_module(library(typedef)).
:- use_module(library(cpp_interface)).

:- cpp_callable
        current_functor(-atom, +integer) = [zero_or_more].
</PRE>
</TABLE>

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

#include &lt;iostream&gt;
#include "myproxy.h&gt;

int 
main(int argc, char **argv)
{ MyProxy proxy("localhost", 4224);

  try
  { between q(&amp;proxy);
    string name;

    while ( q.next_solution(name, 3) )
    { cout &lt;&lt; name &lt;&lt; endl;
    }
  } catch ( PlException &amp;ex )
  { cerr &lt;&lt; (char *)ex;
  }

  return 0;
}
</PRE>
</TABLE>

<H3><A NAME="sec:7.4">7.4 Nesting queries</A></H3>

<A NAME="sec:nestquery"></A>

<P>Non-deterministic queries are initiated by creating an instance of 
its class. The query is said to be <EM>open</EM> as long as the query 
object is not destroyed. New queries, both deterministic and 
non-deterministic can be started while another query is still open. The <EM>nested</EM> 
query however must be closed before more solutions can be asked from the 
query it is nested in.

<P>The example below computes a table of all square roots for the 
numbers 1 to 100 using prolog to generate the numbers on backtracking 
using
<A NAME="idx:between3:5"></A><B>between/3</B> and access to <A NAME="idx:sqrt2:6"></A><B>sqrt/2</B>. 
First the Prolog code, followed by the C++ code.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

:- use_module(library(typedef)).
:- use_module(library(cpp_interface)).

:- cpp_callable
        between(+integer, +integer, -integer) = [zero_or_more],
        sqrt(+float, -float).

sqrt(In, Out) :- Out is sqrt(In).
</PRE>
</TABLE>

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

#include &lt;iostream&gt;
#include "myproxy.h&gt;

int 
main(int argc, char **argv)
{ SqrtProxy proxy("localhost", 4224);

  try
  { between q(&amp;proxy);
    long l = 1;
    long h = 100;
    long i;

    while ( q.next_solution(l, h, i) )
    { double ifloat = (double)i;
      double rval;

      proxy.sqrt(ifloat, rval);
      cout &lt;&lt; "sqrt(" &lt;&lt; i &lt;&lt; ") = " &lt;&lt; rval &lt;&lt; endl;
    }
  } catch ( PlException &amp;ex )
  { cerr &lt;&lt; ex;
  }

  return 0;
}
</PRE>
</TABLE>

<H2><A NAME="sec:8">8 Running the server</A></H2>

<A NAME="sec:server"></A>

<P>For running the server we need a Prolog process with the actual 
predicates and their declarations loaded. We load the library
<CODE>cpp_server</CODE> and invoke <A NAME="idx:cppserver1:7"></A><A HREF="#cpp_server/1">cpp_server/1</A>:

<DL>

<P>
<DT><A NAME="cpp_server/1"><STRONG>cpp_server</STRONG>(<VAR>+Options</VAR>)</A><DD>
Start the C++ server in the current process. This creates a small thread 
with the alias <CODE>cpp_accept</CODE> that accepts new connections and, 
for each new connection, starts a new thread that handles the queries 
for the client. Options include:

<DL>

<P>
<DT><STRONG>port</STRONG>(<VAR>Port</VAR>)<DD>
Port on which to bind the server. Default is 4224.
</DL>

</DL>

<H2><A NAME="sec:9">9 Putting it all together: a complete example</A></H2>

<A NAME="sec:example"></A>

<P>The base-classes for the runtime system are installed in the 
SWI-Prolog include directory as <CODE>SWI-proxy.cpp</CODE> and its 
header
<CODE>SWI-proxy.h</CODE>. These files are <EM>not</EM> compiled into a 
library. Considering compatibility between different compilers and 
compilation models (threading, etc.) it is thought to be easier to 
include this code into the target project using the source-code.

<P>The directory examples (installed as
<CODE>.../pl/doc/packages/examples/cppproxy</CODE>) contains some 
stand-alone examples as well as a <CODE>README</CODE> explaining how to 
compile and run the examples.

<H2><A NAME="sec:10">10 Status</A></H2>

<P>The current implementation is a demonstrator. Issues to be resolved 
in future versions of this package include

<P>
<UL>
<LI><I>Handle arrays</I><BR>
Provide automatic conversion of C++ arrays and/or std library vectors to 
Prolog lists. Currently sets can be extracted from Prolog by enumerating 
a non-deterministic predicate and send to Prolog using repetitive calls. 
Both imply sending many small packages over the wire.

<P>
<LI><I>Authentication and security</I><BR>
Currently the server is `wide open', Limiting the IP for connecting 
hosts is a first step. Other steps are login using password 
challenge/response. Sequence numbers to avoid man-in-the-middle attacks 
and the use of SSL.

<P>
<LI><I>Alternative communication channals</I><BR>
Currently only the TCP/IP version is implemented. See introduction.

<P>
<LI><I>Error recovery</I><BR>
Protocol errors (which can be caused by incompatible proxy and Prolog 
server type declarations) crash the connection. Re-synchronisation is 
difficult to implement. We could do a version check by computing a hash 
from the Prolog interface specification and validate this on 
communication startup.
</UL>

<H3><A NAME="sec:10.1">10.1 Portability</A></H3>

<P>The system is designed to be portable using any modern C++ compiler. 
It has been tested on Linux using g++ 3.3.4 and MS-Windows using MSVC 6.

<H2><A NAME="sec:11">11 Installation</A></H2>

<H3><A NAME="sec:11.1">11.1 Unix systems</A></H3>

<P>Installation on Unix system uses the commonly found <EM>configure</EM>,
<EM>make</EM> and <EM>make install</EM> sequence. SWI-Prolog should be 
installed before building this package. If SWI-Prolog is not installed 
as <B>pl</B>, the environment variable <CODE>PL</CODE> must be set to 
the name of the SWI-Prolog executable. Installation is now accomplished 
using:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

% ./configure
% make
% make install
</PRE>
</TABLE>

<P>This installs the foreign library <CODE>serialize</CODE> in
<CODE>$PLBASE/lib/$PLARCH</CODE> and the Prolog library files in
<CODE>$PLBASE/library</CODE> and the files <CODE>SWI-proxy.cpp</CODE> 
and
<CODE>SWI-proxy.h</CODE> in <CODE>$PLBASE/include</CODE>, where
<CODE>$PLBASE</CODE> refers to the SWI-Prolog `home-directory'.

<H3><A NAME="sec:11.2">11.2 Windows system</A></H3>

<P>If you have successfully installed the system from source you can 
install this package using

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

% nmake /f Makefile.mak
% nmake /f Makefile.mak install
</PRE>
</TABLE>

<P>If not, compile serialize.c using the command below and install the 
files by hand or using the makefile after setting the variable PLBASE to 
the base of the installed Prolog system.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

% plld -o serialize serialize.c
</PRE>
</TABLE>

<H1><A NAME="document-notes">Footnotes</A></H1>

<DL>

<P>
<DT><A NAME=note-1 HREF="index.html#back-to-note-1">note-1</A><DD>
The design allows for limited polymorphism, but this is not yet part of 
the current implementation.
</DL>

<H1><A NAME="document-index">Index</A></H1>

<DL>

<P>
<DT><STRONG>B</STRONG><DD>
<DT>between/3<DD>
<A HREF="#idx:between3:5">7.4</A>
<DT><STRONG>C</STRONG><DD>
<DT><A HREF="#cpp_callable/1">cpp_callable/1</A><DD>
<A HREF="#idx:cppcallable1:1">6</A> <A HREF="#idx:cppcallable1:4">7.3</A>
<DT><A HREF="#cpp_server/1">cpp_server/1</A><DD>
<A HREF="#idx:cppserver1:7">8</A>
<DT><A HREF="#cpp_server_code/2">cpp_server_code/2</A><DD>
<A HREF="#idx:cppservercode2:2">6</A>
<DT><A HREF="#cpp_type/1">cpp_type/1</A><DD>
<DT>cpp_type/2<DD>
<A HREF="#idx:cpptype2:3">7.2</A>
<DT><STRONG>I</STRONG><DD>
<DT><A HREF="#initialize()">initialize()</A><DD>
<DT><STRONG>P</STRONG><DD>
<DT>PlQuery<DD>
<A HREF="#sec:4">4</A>
<DT><STRONG>S</STRONG><DD>
<DT>sqrt/2<DD>
<A HREF="#idx:sqrt2:6">7.4</A>
<DT><STRONG>T</STRONG><DD>
<DT><A HREF="#type/1">type/1</A><DD>
</DL>

</BODY></HTML>